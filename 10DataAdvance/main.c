#include <stdio.h>
#include <string.h>


                   /* 总结一下有关 '\0' 的两组概念*/ 
// I.sizeof 既可求字符串的大小
//          亦可求字符数组的大小,并且将 '\0' 计算在内
//   strlen 在算字符串的长度时不会将 '\0' 计算在内，
//          当这个函数的参数 char* 指向第一个 '\0' 时就相当于触发了循环的跳出条件
//   
//   也就是说 strlen 只能用来求字符串的长度,它不能用来求字符串的大小,因为它做不到!!!!!!
//            sizeof 可以用来求字符数组(当然也就包括字符串喽)的大小,
//                   也可以用来求字符数组的长度 :sizeof(a) / sizeof(a[0])

// II.字符串 "abcd" => {'a','b','c','d','\0'}:只要是字符串,就必须以 '\0' 结尾
//    字符数组1 {'a','b','c','d'}
//    字符数组2 {'a','b','c','d','\0','e','f','\0','\0','x'}
//    有的字符数组中有 '\0' (就像特殊的字符数组:字符串),
//    注意:字符数组不一定必须以 '\0' 结尾,且一个字符数组中可以有一个或多个 '\0'. 
//    有的字符数组中压根就没有 '\0' => 只要是这种字符数组,就一定不是字符串

#if 0
//1111 1111 1111 1111 1111 1111 1111 1110 -2的二进制表示形式(补码)
  //其小端序表示为(低位在低地址上)
  //1111 1110 1111 1111 1111 1111 1111 1111
       0xfe      0xff      0xff      0xff 
  //其大端序表示为(高位在低地址上)
  //1111 1111 1111 1111 1111 1111 1111 1110
       0xff      0xff      0xff      0xfe  
#endif 
       
int IsLittleEnd() {
  int a = 0x11223344;//11是低位，44是高位 
  char* b = (char*)&a;
  if (*b == 0x11) {
    return 0;
  }
  return 1;
}

// 10^(-5)
#define E 1e-5   

int main() {
  // 大多数编程语言不能拿两个浮点数直接比较相等，因为浮点数的存储是存在误差的.
  // 能不用浮点数，就不用浮点数
  // 用整数 
  float i = 19.0;
  float j = i / 7.0;
  if (j * 7.0 - i < E && j * 7.0 - i > -E) {// |j * 7.0 - i| < E 差值的绝对值小于 E 
    printf("ok!\n");
  } else {
    printf("failed!\n");
  }

  // float n = 10;
  // int* p = (int*)&n;
  // printf("%d\n",*p);
  
                    /* 以下都是整型在内存中的存储  */ 
#if 0
  unsigned char i = 0;//unsigned char 的取值范围为:[0,255];
  for (i = 0;i <= 255;++i) {//死循环
    printf("hello world! i = %d\n",i);
  }
#endif 

#if 0
  char a[1000];
  int i;
  for (i = 0;i < 1000;++i) {//这个循环是对 a[1000] 进行初始化
    // a[i] = -1 - i;
    // -1   ff ff ff ff 
    // -2   ff ff ff fe 
    // -3   ff ff ff fd 
    // ...... 
    // -255 ff ff ff 00
    // a[i] = -1 - i// -1 - 255 == 0 -> '\0';
  }
  printf("%d\n",strlen(a));
#endif 

#if 0
  unsigned i;
  //非常经典的错误！
  //当 i == 0 时，下一步就是要 i = i - 1 了；
  //0 - 1 -> 0 + (-1)
  //   0  00 00 00 00
  //+ -1  ff ff ff ff 
  //=     ff ff ff ff 
  //其 以 %u 格式来输出就是 42亿9千万!!!!!!!!!
  for (i = 9;i >= 0;--i) {//这是一个典型的死循环
    printf("%u\n",i);
  }
  //由此可见，无符号整型时有坑的，能不用无符号整型，就尽量不用
#endif 

#if 0
  int i = -20;
  unsigned int j = 10;
  printf("%d\n",i + j);// -> -10
  printf("%u\n",i + j);// -> 4294967286
#endif 

#if 0
  //char 可以表示的有效范围:[-128,127];
  char a = -128;
  printf("%u\n",a);// %u 这个格式化字符串表示的是无符号的整型，即 unsigned int 
  char b = 128;
  printf("%u\n",b);

  这类题的关键点:明确需要输出的格式化字符串类型后,深刻理解由题给数据类型转到题目要求
                 的数据类型所需要的步骤，并搞懂每一步的具体实现过程

  //1000 0000// -> -128
  //   0x80 
  //将 -128 转化为 unsigned int 需要经历两个步骤
      //一:char 转为 int 
      //二：int 转为 unsigned int                                                      
    
  //第一步:依次右移 (32 - 8 ==) 24 个bit位(右移规则是空出的高位bit位由原来的符号位填充)
  //右移 1 位
  //1 1000 0000
  //再右移 1 位
  //11 1000 0000
  //再右移 1 位
  //111 1000 0000
  //再右移 1 位
  //1111 1000 0000
  //......
  //移够 28 个bit位后为
  //1111 1111 1111 1111 1111 1111 1000 0000(此时这个数据理解为 int 型)
  //   0xff      0xff      0xff      0x80 
  
  //第二步:将1111 1111 1111 1111 1111 1111 1000 0000 理解为 unsigned int 
                 //左边为42亿9千万的二进制形式                4294967168   
  1111 1111 1111 1111 1111 1111 1000 0000这是二进制数的表示形式
  不要和大端序、小端序搞混了

  
  //1000 0000// -> 128
  //   0x80
  //将 128 转化为 unsigned int 需要经历两个步骤
       //一:char 转为 int 
       //二：int 转为 unsigned int 
  //........(同上)
  

  //综上可得:第 I 点
  //+128 和 -128:抓住内存的存储形式,有时两个数据在直观上看起来虽然不一样,但是如果它们在内
  //存中的存储形式都一样了,当我们再按照相同的方式来理解,其结果(这里说明一下:指的
  //是计算机对数据的处理结果)也肯定是一样的
  //         第 II 点
  //如果两个数据在内存中存储的形式是相同的，再按照相同的方式去理解时其结果也肯定是相同的
  //(具体更精辟的解释在 01:27:00 ---------> 12.28)
#endif 
  
#if 0
  0000 ->  0
  0001 ->  1
  0010 ->  2
  0011 ->  3
  0100 ->  4
  0101 ->  5
  0110 ->  6
  0111 ->  7
  1000 ->  8
  1001 ->  9
  1010 ->  a
  1011 ->  b
  1100 ->  c
  1101 ->  d
  1110 ->  e
  1111 ->  f
  10 11 12 13 14 15
  a  b  c  d  e  f  
  2
  0000 0010 00 00 00

  低位在低地址上 -> 小端序
  -2
  原码:0000 0010 0000 0000 0000 0000 0000 0001
  反码:1111 1101 1111 1111 1111 1111 1111 1111
  补码:1111 1110 1111 1111 1111 1111 1111 1111
          0xfe      0xff      0xff      0xff 
  
  //因为 char 只占有一个字节,所以 char 型的 -2 在内存中是这样保存的 
  char a = -2;         //1111 1110   
                       //   0xfe -> -2
  signed char b = -2;  //1111 1110
                       //   0xfe -> -2
  unsigned char c = -2;//1111 1110
                       //   0xfe -> 254
  printf("a = %d,b = %d,c = %d\n",a,b,c);
  //数据在内存中具有一定的存储形式，存储同样的内容
  //可以按照不同的方式来理解
#endif 

#if 0
  printf("%d\n",IsLittleEnd());
  int a = -1;//当前机器的 字节序 为小端字节序：即低位存储在低地址上
             //所谓数据的低位高位：符合我们直觉的这个数 00 00 00 0a 中的 a 就是在高位
             //                而不符合我们直觉的这个数 0a 00 00 00 中的 a 就是在低位  
  printf("%d\n",a);
#endif 
  return 0;
}
